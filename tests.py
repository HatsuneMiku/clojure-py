from itertools import chain, repeat
import pprint
from textwrap import dedent
import unittest

from clojure import requireClj
from py.clojure.lang.compiler import Compiler
from py.clojure.lang.fileseq import StringReader
from py.clojure.lang.globals import currentCompiler
from py.clojure.lang.lispreader import read
import py.clojure.lang.rt as RT
from py.clojure.lang.symbol import Symbol
from py.clojure.util.byteplay import Code, Label, SetLineno


requireClj('./clj/clojure/core.clj')


class NonOverloadedFunctions(unittest.TestCase):
    def setUp(self):
        RT.init()
        self.comp = Compiler()
        currentCompiler.set(self.comp)
        self.comp.setNS(Symbol.intern('clojure.core'))

    def testZeroArguments(self):
        actual = self.compileActual('(defn abc [] 2)')
        expected = self.compileExpected('''
            def abc():
                return 2''')
        items = [(a == e, a, e) for a, e in self.zipActualExpected(actual, expected)]
        try:
            assert all(item[0] for item in items)
        except AssertionError:
            pprint.pprint(items)

    def testOneArgument(self):
        actual = self.compileActual('(defn abc ([x] x))')
        expected = self.compileExpected('''
            def abc(x):
                return x''')
        items = [(a == e, a, e) for a, e in self.zipActualExpected(actual, expected)]
        try:
            assert all(item[0] for item in items)
        except AssertionError:
            pprint.pprint(items)

    def testMultipleArguments(self):
        actual = self.compileActual('(defn abc ([x] x) ([x y] y))')
        expected = self.compileExpected('''
            def abc(*__argsv__):
                if __argsv__.__len__() == 1:
                    x = __argsv__[0]
                    return x
                elif __argsv__.__len__() == 2:
                    x = __argsv__[0]
                    y = __argsv__[1]
                    return y
                raise Exception()''')
        # There's a slight different between clojure-py's compiled code and
        # Python's: clojure-py produces (LOAD_CONST, <type 'exceptions.Exception'>)
        # while Python produces (LOAD_CONST, 'Exception'). Just ignore it; it's
        # not what we're testing here.

        # Also the last to two bytecodes generated by Python are to load None
        # and return it, which isn't necessary after raising an exception.
        items = [(a == e, a, e) for a, e in self.zipActualExpected(actual, expected[:-2]) if e[1] != 'Exception']
        try:
            assert all(item[0] for item in items)
        except AssertionError:
            pprint.pprint(items)

    def zipActualExpected(self, actual, expected):
        difference = len(expected) - len(actual)
        return zip(chain(actual, repeat(None, difference)),
                   chain(expected, repeat(None, -difference)))

    def compileActual(self, code):
        r = StringReader(code)
        s = read(r, True, None, True)
        res = self.comp.compile(s)
        fn = self.comp.executeCode(res)
        return [c for c in Code.from_code(fn.func_code).code[:] if c[0] is not SetLineno]

    def compileExpected(self, code):
        codeobject = compile(dedent(code), 'string', 'exec')
        globs = {}
        result = eval(codeobject, {}, globs)
        return [c for c in Code.from_code(globs['abc'].func_code).code[:] if c[0] is not SetLineno]
